<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>


    <script>
        /**
         *  let 声明的范围是块级作用域,而var声明的范围是函数作用域。
         *  age变量之所以不能在if 块外部被引用, 是因为它的作用域仅限于该块内部。
         *  块作用域是函数作用域的子集,因此适用于var 的作用域 限制同样也适用于let
         */
        if (true) {
            var name = 'Matt';
            console.log(name)
        }
        console.log(name)
        if (true) {
            let age = 26
            console.log(age)
        }
        console.log(age)
    </script>
    <script>
        /**
         *  let 不允许 同一个块级作用域 出现冗余申明,这样会导致报错
         */
        var name;
        var name;
        let age1;
        let age1;
    </script>
    <script>
        /**
         *  js引擎会记录用于变量盛名的标识符及其所在的块级作用域
         */
        var name = '和风'
        console.log(name)
        if (true) {
            var name = 'Matt';
            console.log(name); // 'Matt'
        }
        let age = 30;
        console.log(age)
        if (true) {
            let age = 26;
            console.log(age);
        }
    </script>
    <script>
        /**
         *  对 申明冗余报错不会因混用 let 和var 而受影响。
         *  它们 只是指出变量在相关作用域如何存在
         *  
         */
        var name;
        let name;
        let age1;
        var age1;
    </script>
    <script>
        /**
         *  暂时性死区
         *  let 与var的另一个重要的区别,就是let声明 变量不会在作用域中被提升
         *  
         */
        // name 会被提升
        console.log(nameFend);
        var nameFend = '和风111';
        console.log(nameFend);
        //  age 不会被提升
        console.log(age12);
        let age12 = 26;
    </script>
    <script>
        /**
         *  全局声明
         *  let在全局作用域中 声明的变量不会成为 window对象的属性
         *  var在全局作用域中 声明的变量 会成为 window对象的属性
         *  let仍然在全局作用域中发生,会在页面的生命周期内存续
         */
        var name = 'Matt';
        console.log(window.name)
        let age1 = 26;
        console.log(window.age1)
    </script>
    <script>
        /**
         *  条件声明
         *  var 自动将多余的申明在作用域顶部合并为一个声明
         *  同时也就不可能在没有声明的情况下声明它
         *  try/catch 也不能解决 因为
         */
        let age = 26;
        console.log(window.age)
    </script>
    <script>
        /**
         *  在let出现之前, for 循环定义的迭代变量会渗透到循环体外部
         *  let 迭代变量的作用域仅限于for 循环块级作用域
         * 
         */
        for (var i = 0; i < 5; i++) {
            console.log(i)
        }
        console.log(i)
        for (let j = 0; j < 5; j++) {
            console.log(j)
        }
        // console.log(j)
        /**
         * 输出都是5  迭代变量保存的是导致循环推出的值 :5
         * 在之后执行超出逻辑时, 所有的i都是同一个变量,因此同一个最终值
         * 
         */
        for (var z = 0; z < 5; z++) {
            setTimeout(() => {
                console.log(z)
            }, 0);
        }
        /**
         *   会为每个迭代循环声明 一个新的迭代变量
         *   每个setTimeout 引用的是不同的变量实例,
         */
        for (var x = 0; x < 5; x++) {
            setTimeout(() => {
                console.log(x)
            }, 0);
        }
        /**
         * 
         */
    </script>

</body>

</html>